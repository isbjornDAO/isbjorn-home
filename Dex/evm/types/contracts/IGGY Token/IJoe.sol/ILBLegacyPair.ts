/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export declare namespace ILBLegacyPair {
  export type FeeParametersStruct = {
    binStep: BigNumberish;
    baseFactor: BigNumberish;
    filterPeriod: BigNumberish;
    decayPeriod: BigNumberish;
    reductionFactor: BigNumberish;
    variableFeeControl: BigNumberish;
    protocolShare: BigNumberish;
    maxVolatilityAccumulated: BigNumberish;
    volatilityAccumulated: BigNumberish;
    volatilityReference: BigNumberish;
    indexRef: BigNumberish;
    time: BigNumberish;
  };

  export type FeeParametersStructOutput = [
    binStep: bigint,
    baseFactor: bigint,
    filterPeriod: bigint,
    decayPeriod: bigint,
    reductionFactor: bigint,
    variableFeeControl: bigint,
    protocolShare: bigint,
    maxVolatilityAccumulated: bigint,
    volatilityAccumulated: bigint,
    volatilityReference: bigint,
    indexRef: bigint,
    time: bigint
  ] & {
    binStep: bigint;
    baseFactor: bigint;
    filterPeriod: bigint;
    decayPeriod: bigint;
    reductionFactor: bigint;
    variableFeeControl: bigint;
    protocolShare: bigint;
    maxVolatilityAccumulated: bigint;
    volatilityAccumulated: bigint;
    volatilityReference: bigint;
    indexRef: bigint;
    time: bigint;
  };
}

export interface ILBLegacyPairInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "balanceOf"
      | "balanceOfBatch"
      | "burn"
      | "collectFees"
      | "collectProtocolFees"
      | "factory"
      | "feeParameters"
      | "findFirstNonEmptyBinId"
      | "flashLoan"
      | "forceDecay"
      | "getBin"
      | "getGlobalFees"
      | "getOracleParameters"
      | "getOracleSampleFrom"
      | "getReservesAndId"
      | "increaseOracleLength"
      | "initialize"
      | "isApprovedForAll"
      | "mint"
      | "name"
      | "pendingFees"
      | "safeBatchTransferFrom"
      | "safeTransferFrom"
      | "setApprovalForAll"
      | "setFeesParameters"
      | "supportsInterface"
      | "swap"
      | "symbol"
      | "tokenX"
      | "tokenY"
      | "totalSupply"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ApprovalForAll"
      | "CompositionFee"
      | "DepositedToBin"
      | "FeesCollected"
      | "FlashLoan"
      | "OracleSizeIncreased"
      | "ProtocolFeesCollected"
      | "Swap"
      | "TransferBatch"
      | "TransferSingle"
      | "WithdrawnFromBin"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOfBatch",
    values: [AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "burn",
    values: [BigNumberish[], BigNumberish[], AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "collectFees",
    values: [AddressLike, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "collectProtocolFees",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "factory", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "feeParameters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "findFirstNonEmptyBinId",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "flashLoan",
    values: [AddressLike, AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "forceDecay",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBin",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getGlobalFees",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOracleParameters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOracleSampleFrom",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getReservesAndId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "increaseOracleLength",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [BigNumberish[], BigNumberish[], BigNumberish[], AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingFees",
    values: [AddressLike, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "safeBatchTransferFrom",
    values: [AddressLike, AddressLike, BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeesParameters",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "swap",
    values: [boolean, AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(functionFragment: "tokenX", values?: undefined): string;
  encodeFunctionData(functionFragment: "tokenY", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "balanceOfBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "collectFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collectProtocolFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "feeParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findFirstNonEmptyBinId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "flashLoan", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "forceDecay", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getBin", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getGlobalFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOracleParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOracleSampleFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReservesAndId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "increaseOracleLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeBatchTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeesParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenX", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenY", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
}

export namespace ApprovalForAllEvent {
  export type InputTuple = [
    account: AddressLike,
    sender: AddressLike,
    approved: boolean
  ];
  export type OutputTuple = [
    account: string,
    sender: string,
    approved: boolean
  ];
  export interface OutputObject {
    account: string;
    sender: string;
    approved: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CompositionFeeEvent {
  export type InputTuple = [
    sender: AddressLike,
    recipient: AddressLike,
    id: BigNumberish,
    feesX: BigNumberish,
    feesY: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    recipient: string,
    id: bigint,
    feesX: bigint,
    feesY: bigint
  ];
  export interface OutputObject {
    sender: string;
    recipient: string;
    id: bigint;
    feesX: bigint;
    feesY: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DepositedToBinEvent {
  export type InputTuple = [
    sender: AddressLike,
    recipient: AddressLike,
    id: BigNumberish,
    amountX: BigNumberish,
    amountY: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    recipient: string,
    id: bigint,
    amountX: bigint,
    amountY: bigint
  ];
  export interface OutputObject {
    sender: string;
    recipient: string;
    id: bigint;
    amountX: bigint;
    amountY: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FeesCollectedEvent {
  export type InputTuple = [
    sender: AddressLike,
    recipient: AddressLike,
    amountX: BigNumberish,
    amountY: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    recipient: string,
    amountX: bigint,
    amountY: bigint
  ];
  export interface OutputObject {
    sender: string;
    recipient: string;
    amountX: bigint;
    amountY: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FlashLoanEvent {
  export type InputTuple = [
    sender: AddressLike,
    receiver: AddressLike,
    token: AddressLike,
    amount: BigNumberish,
    fee: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    receiver: string,
    token: string,
    amount: bigint,
    fee: bigint
  ];
  export interface OutputObject {
    sender: string;
    receiver: string;
    token: string;
    amount: bigint;
    fee: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OracleSizeIncreasedEvent {
  export type InputTuple = [previousSize: BigNumberish, newSize: BigNumberish];
  export type OutputTuple = [previousSize: bigint, newSize: bigint];
  export interface OutputObject {
    previousSize: bigint;
    newSize: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ProtocolFeesCollectedEvent {
  export type InputTuple = [
    sender: AddressLike,
    recipient: AddressLike,
    amountX: BigNumberish,
    amountY: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    recipient: string,
    amountX: bigint,
    amountY: bigint
  ];
  export interface OutputObject {
    sender: string;
    recipient: string;
    amountX: bigint;
    amountY: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapEvent {
  export type InputTuple = [
    sender: AddressLike,
    recipient: AddressLike,
    id: BigNumberish,
    swapForY: boolean,
    amountIn: BigNumberish,
    amountOut: BigNumberish,
    volatilityAccumulated: BigNumberish,
    fees: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    recipient: string,
    id: bigint,
    swapForY: boolean,
    amountIn: bigint,
    amountOut: bigint,
    volatilityAccumulated: bigint,
    fees: bigint
  ];
  export interface OutputObject {
    sender: string;
    recipient: string;
    id: bigint;
    swapForY: boolean;
    amountIn: bigint;
    amountOut: bigint;
    volatilityAccumulated: bigint;
    fees: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferBatchEvent {
  export type InputTuple = [
    sender: AddressLike,
    from: AddressLike,
    to: AddressLike,
    ids: BigNumberish[],
    amounts: BigNumberish[]
  ];
  export type OutputTuple = [
    sender: string,
    from: string,
    to: string,
    ids: bigint[],
    amounts: bigint[]
  ];
  export interface OutputObject {
    sender: string;
    from: string;
    to: string;
    ids: bigint[];
    amounts: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferSingleEvent {
  export type InputTuple = [
    sender: AddressLike,
    from: AddressLike,
    to: AddressLike,
    id: BigNumberish,
    amount: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    from: string,
    to: string,
    id: bigint,
    amount: bigint
  ];
  export interface OutputObject {
    sender: string;
    from: string;
    to: string;
    id: bigint;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WithdrawnFromBinEvent {
  export type InputTuple = [
    sender: AddressLike,
    recipient: AddressLike,
    id: BigNumberish,
    amountX: BigNumberish,
    amountY: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    recipient: string,
    id: bigint,
    amountX: bigint,
    amountY: bigint
  ];
  export interface OutputObject {
    sender: string;
    recipient: string;
    id: bigint;
    amountX: bigint;
    amountY: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface ILBLegacyPair extends BaseContract {
  connect(runner?: ContractRunner | null): ILBLegacyPair;
  waitForDeployment(): Promise<this>;

  interface: ILBLegacyPairInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  balanceOf: TypedContractMethod<
    [account: AddressLike, id: BigNumberish],
    [bigint],
    "view"
  >;

  balanceOfBatch: TypedContractMethod<
    [accounts: AddressLike[], ids: BigNumberish[]],
    [bigint[]],
    "view"
  >;

  burn: TypedContractMethod<
    [ids: BigNumberish[], amounts: BigNumberish[], to: AddressLike],
    [[bigint, bigint] & { amountX: bigint; amountY: bigint }],
    "nonpayable"
  >;

  collectFees: TypedContractMethod<
    [account: AddressLike, ids: BigNumberish[]],
    [[bigint, bigint] & { amountX: bigint; amountY: bigint }],
    "nonpayable"
  >;

  collectProtocolFees: TypedContractMethod<
    [],
    [[bigint, bigint] & { amountX: bigint; amountY: bigint }],
    "nonpayable"
  >;

  factory: TypedContractMethod<[], [string], "view">;

  feeParameters: TypedContractMethod<
    [],
    [ILBLegacyPair.FeeParametersStructOutput],
    "view"
  >;

  findFirstNonEmptyBinId: TypedContractMethod<
    [id_: BigNumberish, sentTokenY: boolean],
    [bigint],
    "view"
  >;

  flashLoan: TypedContractMethod<
    [
      receiver: AddressLike,
      token: AddressLike,
      amount: BigNumberish,
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  forceDecay: TypedContractMethod<[], [void], "nonpayable">;

  getBin: TypedContractMethod<
    [id: BigNumberish],
    [[bigint, bigint] & { reserveX: bigint; reserveY: bigint }],
    "view"
  >;

  getGlobalFees: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint] & {
        feesXTotal: bigint;
        feesYTotal: bigint;
        feesXProtocol: bigint;
        feesYProtocol: bigint;
      }
    ],
    "view"
  >;

  getOracleParameters: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {
        oracleSampleLifetime: bigint;
        oracleSize: bigint;
        oracleActiveSize: bigint;
        oracleLastTimestamp: bigint;
        oracleId: bigint;
        min: bigint;
        max: bigint;
      }
    ],
    "view"
  >;

  getOracleSampleFrom: TypedContractMethod<
    [timeDelta: BigNumberish],
    [
      [bigint, bigint, bigint] & {
        cumulativeId: bigint;
        cumulativeAccumulator: bigint;
        cumulativeBinCrossed: bigint;
      }
    ],
    "view"
  >;

  getReservesAndId: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint] & {
        reserveX: bigint;
        reserveY: bigint;
        activeId: bigint;
      }
    ],
    "view"
  >;

  increaseOracleLength: TypedContractMethod<
    [newSize: BigNumberish],
    [void],
    "nonpayable"
  >;

  initialize: TypedContractMethod<
    [
      tokenX: AddressLike,
      tokenY: AddressLike,
      activeId: BigNumberish,
      sampleLifetime: BigNumberish,
      packedFeeParameters: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  isApprovedForAll: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [boolean],
    "view"
  >;

  mint: TypedContractMethod<
    [
      ids: BigNumberish[],
      distributionX: BigNumberish[],
      distributionY: BigNumberish[],
      to: AddressLike
    ],
    [
      [bigint, bigint, bigint[]] & {
        amountXAddedToPair: bigint;
        amountYAddedToPair: bigint;
        liquidityMinted: bigint[];
      }
    ],
    "nonpayable"
  >;

  name: TypedContractMethod<[], [string], "view">;

  pendingFees: TypedContractMethod<
    [account: AddressLike, ids: BigNumberish[]],
    [[bigint, bigint] & { amountX: bigint; amountY: bigint }],
    "view"
  >;

  safeBatchTransferFrom: TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      id: BigNumberish[],
      amount: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;

  safeTransferFrom: TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      id: BigNumberish,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  setApprovalForAll: TypedContractMethod<
    [sender: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;

  setFeesParameters: TypedContractMethod<
    [packedFeeParameters: BytesLike],
    [void],
    "nonpayable"
  >;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  swap: TypedContractMethod<
    [sentTokenY: boolean, to: AddressLike],
    [[bigint, bigint] & { amountXOut: bigint; amountYOut: bigint }],
    "nonpayable"
  >;

  symbol: TypedContractMethod<[], [string], "view">;

  tokenX: TypedContractMethod<[], [string], "view">;

  tokenY: TypedContractMethod<[], [string], "view">;

  totalSupply: TypedContractMethod<[id: BigNumberish], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<
    [account: AddressLike, id: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "balanceOfBatch"
  ): TypedContractMethod<
    [accounts: AddressLike[], ids: BigNumberish[]],
    [bigint[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "burn"
  ): TypedContractMethod<
    [ids: BigNumberish[], amounts: BigNumberish[], to: AddressLike],
    [[bigint, bigint] & { amountX: bigint; amountY: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "collectFees"
  ): TypedContractMethod<
    [account: AddressLike, ids: BigNumberish[]],
    [[bigint, bigint] & { amountX: bigint; amountY: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "collectProtocolFees"
  ): TypedContractMethod<
    [],
    [[bigint, bigint] & { amountX: bigint; amountY: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "factory"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "feeParameters"
  ): TypedContractMethod<[], [ILBLegacyPair.FeeParametersStructOutput], "view">;
  getFunction(
    nameOrSignature: "findFirstNonEmptyBinId"
  ): TypedContractMethod<
    [id_: BigNumberish, sentTokenY: boolean],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "flashLoan"
  ): TypedContractMethod<
    [
      receiver: AddressLike,
      token: AddressLike,
      amount: BigNumberish,
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "forceDecay"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getBin"
  ): TypedContractMethod<
    [id: BigNumberish],
    [[bigint, bigint] & { reserveX: bigint; reserveY: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "getGlobalFees"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint] & {
        feesXTotal: bigint;
        feesYTotal: bigint;
        feesXProtocol: bigint;
        feesYProtocol: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOracleParameters"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {
        oracleSampleLifetime: bigint;
        oracleSize: bigint;
        oracleActiveSize: bigint;
        oracleLastTimestamp: bigint;
        oracleId: bigint;
        min: bigint;
        max: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOracleSampleFrom"
  ): TypedContractMethod<
    [timeDelta: BigNumberish],
    [
      [bigint, bigint, bigint] & {
        cumulativeId: bigint;
        cumulativeAccumulator: bigint;
        cumulativeBinCrossed: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getReservesAndId"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint] & {
        reserveX: bigint;
        reserveY: bigint;
        activeId: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "increaseOracleLength"
  ): TypedContractMethod<[newSize: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "initialize"
  ): TypedContractMethod<
    [
      tokenX: AddressLike,
      tokenY: AddressLike,
      activeId: BigNumberish,
      sampleLifetime: BigNumberish,
      packedFeeParameters: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isApprovedForAll"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "mint"
  ): TypedContractMethod<
    [
      ids: BigNumberish[],
      distributionX: BigNumberish[],
      distributionY: BigNumberish[],
      to: AddressLike
    ],
    [
      [bigint, bigint, bigint[]] & {
        amountXAddedToPair: bigint;
        amountYAddedToPair: bigint;
        liquidityMinted: bigint[];
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "pendingFees"
  ): TypedContractMethod<
    [account: AddressLike, ids: BigNumberish[]],
    [[bigint, bigint] & { amountX: bigint; amountY: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "safeBatchTransferFrom"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      id: BigNumberish[],
      amount: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "safeTransferFrom"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      id: BigNumberish,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setApprovalForAll"
  ): TypedContractMethod<
    [sender: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setFeesParameters"
  ): TypedContractMethod<
    [packedFeeParameters: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "swap"
  ): TypedContractMethod<
    [sentTokenY: boolean, to: AddressLike],
    [[bigint, bigint] & { amountXOut: bigint; amountYOut: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "tokenX"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "tokenY"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[id: BigNumberish], [bigint], "view">;

  getEvent(
    key: "ApprovalForAll"
  ): TypedContractEvent<
    ApprovalForAllEvent.InputTuple,
    ApprovalForAllEvent.OutputTuple,
    ApprovalForAllEvent.OutputObject
  >;
  getEvent(
    key: "CompositionFee"
  ): TypedContractEvent<
    CompositionFeeEvent.InputTuple,
    CompositionFeeEvent.OutputTuple,
    CompositionFeeEvent.OutputObject
  >;
  getEvent(
    key: "DepositedToBin"
  ): TypedContractEvent<
    DepositedToBinEvent.InputTuple,
    DepositedToBinEvent.OutputTuple,
    DepositedToBinEvent.OutputObject
  >;
  getEvent(
    key: "FeesCollected"
  ): TypedContractEvent<
    FeesCollectedEvent.InputTuple,
    FeesCollectedEvent.OutputTuple,
    FeesCollectedEvent.OutputObject
  >;
  getEvent(
    key: "FlashLoan"
  ): TypedContractEvent<
    FlashLoanEvent.InputTuple,
    FlashLoanEvent.OutputTuple,
    FlashLoanEvent.OutputObject
  >;
  getEvent(
    key: "OracleSizeIncreased"
  ): TypedContractEvent<
    OracleSizeIncreasedEvent.InputTuple,
    OracleSizeIncreasedEvent.OutputTuple,
    OracleSizeIncreasedEvent.OutputObject
  >;
  getEvent(
    key: "ProtocolFeesCollected"
  ): TypedContractEvent<
    ProtocolFeesCollectedEvent.InputTuple,
    ProtocolFeesCollectedEvent.OutputTuple,
    ProtocolFeesCollectedEvent.OutputObject
  >;
  getEvent(
    key: "Swap"
  ): TypedContractEvent<
    SwapEvent.InputTuple,
    SwapEvent.OutputTuple,
    SwapEvent.OutputObject
  >;
  getEvent(
    key: "TransferBatch"
  ): TypedContractEvent<
    TransferBatchEvent.InputTuple,
    TransferBatchEvent.OutputTuple,
    TransferBatchEvent.OutputObject
  >;
  getEvent(
    key: "TransferSingle"
  ): TypedContractEvent<
    TransferSingleEvent.InputTuple,
    TransferSingleEvent.OutputTuple,
    TransferSingleEvent.OutputObject
  >;
  getEvent(
    key: "WithdrawnFromBin"
  ): TypedContractEvent<
    WithdrawnFromBinEvent.InputTuple,
    WithdrawnFromBinEvent.OutputTuple,
    WithdrawnFromBinEvent.OutputObject
  >;

  filters: {
    "ApprovalForAll(address,address,bool)": TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;
    ApprovalForAll: TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;

    "CompositionFee(address,address,uint256,uint256,uint256)": TypedContractEvent<
      CompositionFeeEvent.InputTuple,
      CompositionFeeEvent.OutputTuple,
      CompositionFeeEvent.OutputObject
    >;
    CompositionFee: TypedContractEvent<
      CompositionFeeEvent.InputTuple,
      CompositionFeeEvent.OutputTuple,
      CompositionFeeEvent.OutputObject
    >;

    "DepositedToBin(address,address,uint256,uint256,uint256)": TypedContractEvent<
      DepositedToBinEvent.InputTuple,
      DepositedToBinEvent.OutputTuple,
      DepositedToBinEvent.OutputObject
    >;
    DepositedToBin: TypedContractEvent<
      DepositedToBinEvent.InputTuple,
      DepositedToBinEvent.OutputTuple,
      DepositedToBinEvent.OutputObject
    >;

    "FeesCollected(address,address,uint256,uint256)": TypedContractEvent<
      FeesCollectedEvent.InputTuple,
      FeesCollectedEvent.OutputTuple,
      FeesCollectedEvent.OutputObject
    >;
    FeesCollected: TypedContractEvent<
      FeesCollectedEvent.InputTuple,
      FeesCollectedEvent.OutputTuple,
      FeesCollectedEvent.OutputObject
    >;

    "FlashLoan(address,address,address,uint256,uint256)": TypedContractEvent<
      FlashLoanEvent.InputTuple,
      FlashLoanEvent.OutputTuple,
      FlashLoanEvent.OutputObject
    >;
    FlashLoan: TypedContractEvent<
      FlashLoanEvent.InputTuple,
      FlashLoanEvent.OutputTuple,
      FlashLoanEvent.OutputObject
    >;

    "OracleSizeIncreased(uint256,uint256)": TypedContractEvent<
      OracleSizeIncreasedEvent.InputTuple,
      OracleSizeIncreasedEvent.OutputTuple,
      OracleSizeIncreasedEvent.OutputObject
    >;
    OracleSizeIncreased: TypedContractEvent<
      OracleSizeIncreasedEvent.InputTuple,
      OracleSizeIncreasedEvent.OutputTuple,
      OracleSizeIncreasedEvent.OutputObject
    >;

    "ProtocolFeesCollected(address,address,uint256,uint256)": TypedContractEvent<
      ProtocolFeesCollectedEvent.InputTuple,
      ProtocolFeesCollectedEvent.OutputTuple,
      ProtocolFeesCollectedEvent.OutputObject
    >;
    ProtocolFeesCollected: TypedContractEvent<
      ProtocolFeesCollectedEvent.InputTuple,
      ProtocolFeesCollectedEvent.OutputTuple,
      ProtocolFeesCollectedEvent.OutputObject
    >;

    "Swap(address,address,uint256,bool,uint256,uint256,uint256,uint256)": TypedContractEvent<
      SwapEvent.InputTuple,
      SwapEvent.OutputTuple,
      SwapEvent.OutputObject
    >;
    Swap: TypedContractEvent<
      SwapEvent.InputTuple,
      SwapEvent.OutputTuple,
      SwapEvent.OutputObject
    >;

    "TransferBatch(address,address,address,uint256[],uint256[])": TypedContractEvent<
      TransferBatchEvent.InputTuple,
      TransferBatchEvent.OutputTuple,
      TransferBatchEvent.OutputObject
    >;
    TransferBatch: TypedContractEvent<
      TransferBatchEvent.InputTuple,
      TransferBatchEvent.OutputTuple,
      TransferBatchEvent.OutputObject
    >;

    "TransferSingle(address,address,address,uint256,uint256)": TypedContractEvent<
      TransferSingleEvent.InputTuple,
      TransferSingleEvent.OutputTuple,
      TransferSingleEvent.OutputObject
    >;
    TransferSingle: TypedContractEvent<
      TransferSingleEvent.InputTuple,
      TransferSingleEvent.OutputTuple,
      TransferSingleEvent.OutputObject
    >;

    "WithdrawnFromBin(address,address,uint256,uint256,uint256)": TypedContractEvent<
      WithdrawnFromBinEvent.InputTuple,
      WithdrawnFromBinEvent.OutputTuple,
      WithdrawnFromBinEvent.OutputObject
    >;
    WithdrawnFromBin: TypedContractEvent<
      WithdrawnFromBinEvent.InputTuple,
      WithdrawnFromBinEvent.OutputTuple,
      WithdrawnFromBinEvent.OutputObject
    >;
  };
}
