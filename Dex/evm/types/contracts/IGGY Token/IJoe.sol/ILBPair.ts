/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export interface ILBPairInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "approveForAll"
      | "balanceOf"
      | "balanceOfBatch"
      | "batchTransferFrom"
      | "burn"
      | "collectProtocolFees"
      | "flashLoan"
      | "forceDecay"
      | "getActiveId"
      | "getBin"
      | "getBinStep"
      | "getFactory"
      | "getIdFromPrice"
      | "getNextNonEmptyBin"
      | "getOracleParameters"
      | "getOracleSampleAt"
      | "getPriceFromId"
      | "getProtocolFees"
      | "getReserves"
      | "getStaticFeeParameters"
      | "getSwapIn"
      | "getSwapOut"
      | "getTokenX"
      | "getTokenY"
      | "getVariableFeeParameters"
      | "increaseOracleLength"
      | "initialize"
      | "isApprovedForAll"
      | "mint"
      | "name"
      | "setStaticFeeParameters"
      | "swap"
      | "symbol"
      | "totalSupply"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ApprovalForAll"
      | "CollectedProtocolFees"
      | "CompositionFees"
      | "DepositedToBins"
      | "FlashLoan"
      | "ForcedDecay"
      | "OracleLengthIncreased"
      | "StaticFeeParametersSet"
      | "Swap"
      | "TransferBatch"
      | "WithdrawnFromBins"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "approveForAll",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOfBatch",
    values: [AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchTransferFrom",
    values: [AddressLike, AddressLike, BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "burn",
    values: [AddressLike, AddressLike, BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "collectProtocolFees",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "flashLoan",
    values: [AddressLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "forceDecay",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBin",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getBinStep",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getFactory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getIdFromPrice",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getNextNonEmptyBin",
    values: [boolean, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getOracleParameters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOracleSampleAt",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPriceFromId",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getProtocolFees",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStaticFeeParameters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapIn",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapOut",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(functionFragment: "getTokenX", values?: undefined): string;
  encodeFunctionData(functionFragment: "getTokenY", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getVariableFeeParameters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "increaseOracleLength",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [AddressLike, BytesLike[], AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setStaticFeeParameters",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swap",
    values: [boolean, AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "approveForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "balanceOfBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "collectProtocolFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "flashLoan", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "forceDecay", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getActiveId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getBin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getBinStep", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getFactory", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getIdFromPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNextNonEmptyBin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOracleParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOracleSampleAt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPriceFromId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProtocolFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStaticFeeParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getSwapIn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getSwapOut", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getTokenX", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getTokenY", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getVariableFeeParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "increaseOracleLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setStaticFeeParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
}

export namespace ApprovalForAllEvent {
  export type InputTuple = [
    account: AddressLike,
    sender: AddressLike,
    approved: boolean
  ];
  export type OutputTuple = [
    account: string,
    sender: string,
    approved: boolean
  ];
  export interface OutputObject {
    account: string;
    sender: string;
    approved: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CollectedProtocolFeesEvent {
  export type InputTuple = [feeRecipient: AddressLike, protocolFees: BytesLike];
  export type OutputTuple = [feeRecipient: string, protocolFees: string];
  export interface OutputObject {
    feeRecipient: string;
    protocolFees: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CompositionFeesEvent {
  export type InputTuple = [
    sender: AddressLike,
    id: BigNumberish,
    totalFees: BytesLike,
    protocolFees: BytesLike
  ];
  export type OutputTuple = [
    sender: string,
    id: bigint,
    totalFees: string,
    protocolFees: string
  ];
  export interface OutputObject {
    sender: string;
    id: bigint;
    totalFees: string;
    protocolFees: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DepositedToBinsEvent {
  export type InputTuple = [
    sender: AddressLike,
    to: AddressLike,
    ids: BigNumberish[],
    amounts: BytesLike[]
  ];
  export type OutputTuple = [
    sender: string,
    to: string,
    ids: bigint[],
    amounts: string[]
  ];
  export interface OutputObject {
    sender: string;
    to: string;
    ids: bigint[];
    amounts: string[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FlashLoanEvent {
  export type InputTuple = [
    sender: AddressLike,
    receiver: AddressLike,
    activeId: BigNumberish,
    amounts: BytesLike,
    totalFees: BytesLike,
    protocolFees: BytesLike
  ];
  export type OutputTuple = [
    sender: string,
    receiver: string,
    activeId: bigint,
    amounts: string,
    totalFees: string,
    protocolFees: string
  ];
  export interface OutputObject {
    sender: string;
    receiver: string;
    activeId: bigint;
    amounts: string;
    totalFees: string;
    protocolFees: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ForcedDecayEvent {
  export type InputTuple = [
    sender: AddressLike,
    idReference: BigNumberish,
    volatilityReference: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    idReference: bigint,
    volatilityReference: bigint
  ];
  export interface OutputObject {
    sender: string;
    idReference: bigint;
    volatilityReference: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OracleLengthIncreasedEvent {
  export type InputTuple = [sender: AddressLike, oracleLength: BigNumberish];
  export type OutputTuple = [sender: string, oracleLength: bigint];
  export interface OutputObject {
    sender: string;
    oracleLength: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace StaticFeeParametersSetEvent {
  export type InputTuple = [
    sender: AddressLike,
    baseFactor: BigNumberish,
    filterPeriod: BigNumberish,
    decayPeriod: BigNumberish,
    reductionFactor: BigNumberish,
    variableFeeControl: BigNumberish,
    protocolShare: BigNumberish,
    maxVolatilityAccumulator: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    baseFactor: bigint,
    filterPeriod: bigint,
    decayPeriod: bigint,
    reductionFactor: bigint,
    variableFeeControl: bigint,
    protocolShare: bigint,
    maxVolatilityAccumulator: bigint
  ];
  export interface OutputObject {
    sender: string;
    baseFactor: bigint;
    filterPeriod: bigint;
    decayPeriod: bigint;
    reductionFactor: bigint;
    variableFeeControl: bigint;
    protocolShare: bigint;
    maxVolatilityAccumulator: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapEvent {
  export type InputTuple = [
    sender: AddressLike,
    to: AddressLike,
    id: BigNumberish,
    amountsIn: BytesLike,
    amountsOut: BytesLike,
    volatilityAccumulator: BigNumberish,
    totalFees: BytesLike,
    protocolFees: BytesLike
  ];
  export type OutputTuple = [
    sender: string,
    to: string,
    id: bigint,
    amountsIn: string,
    amountsOut: string,
    volatilityAccumulator: bigint,
    totalFees: string,
    protocolFees: string
  ];
  export interface OutputObject {
    sender: string;
    to: string;
    id: bigint;
    amountsIn: string;
    amountsOut: string;
    volatilityAccumulator: bigint;
    totalFees: string;
    protocolFees: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferBatchEvent {
  export type InputTuple = [
    sender: AddressLike,
    from: AddressLike,
    to: AddressLike,
    ids: BigNumberish[],
    amounts: BigNumberish[]
  ];
  export type OutputTuple = [
    sender: string,
    from: string,
    to: string,
    ids: bigint[],
    amounts: bigint[]
  ];
  export interface OutputObject {
    sender: string;
    from: string;
    to: string;
    ids: bigint[];
    amounts: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WithdrawnFromBinsEvent {
  export type InputTuple = [
    sender: AddressLike,
    to: AddressLike,
    ids: BigNumberish[],
    amounts: BytesLike[]
  ];
  export type OutputTuple = [
    sender: string,
    to: string,
    ids: bigint[],
    amounts: string[]
  ];
  export interface OutputObject {
    sender: string;
    to: string;
    ids: bigint[];
    amounts: string[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface ILBPair extends BaseContract {
  connect(runner?: ContractRunner | null): ILBPair;
  waitForDeployment(): Promise<this>;

  interface: ILBPairInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  approveForAll: TypedContractMethod<
    [spender: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<
    [account: AddressLike, id: BigNumberish],
    [bigint],
    "view"
  >;

  balanceOfBatch: TypedContractMethod<
    [accounts: AddressLike[], ids: BigNumberish[]],
    [bigint[]],
    "view"
  >;

  batchTransferFrom: TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      ids: BigNumberish[],
      amounts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;

  burn: TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      ids: BigNumberish[],
      amountsToBurn: BigNumberish[]
    ],
    [string[]],
    "nonpayable"
  >;

  collectProtocolFees: TypedContractMethod<[], [string], "nonpayable">;

  flashLoan: TypedContractMethod<
    [receiver: AddressLike, amounts: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  forceDecay: TypedContractMethod<[], [void], "nonpayable">;

  getActiveId: TypedContractMethod<[], [bigint], "view">;

  getBin: TypedContractMethod<
    [id: BigNumberish],
    [[bigint, bigint] & { binReserveX: bigint; binReserveY: bigint }],
    "view"
  >;

  getBinStep: TypedContractMethod<[], [bigint], "view">;

  getFactory: TypedContractMethod<[], [string], "view">;

  getIdFromPrice: TypedContractMethod<[price: BigNumberish], [bigint], "view">;

  getNextNonEmptyBin: TypedContractMethod<
    [swapForY: boolean, id: BigNumberish],
    [bigint],
    "view"
  >;

  getOracleParameters: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint] & {
        sampleLifetime: bigint;
        size: bigint;
        activeSize: bigint;
        lastUpdated: bigint;
        firstTimestamp: bigint;
      }
    ],
    "view"
  >;

  getOracleSampleAt: TypedContractMethod<
    [lookupTimestamp: BigNumberish],
    [
      [bigint, bigint, bigint] & {
        cumulativeId: bigint;
        cumulativeVolatility: bigint;
        cumulativeBinCrossed: bigint;
      }
    ],
    "view"
  >;

  getPriceFromId: TypedContractMethod<[id: BigNumberish], [bigint], "view">;

  getProtocolFees: TypedContractMethod<
    [],
    [[bigint, bigint] & { protocolFeeX: bigint; protocolFeeY: bigint }],
    "view"
  >;

  getReserves: TypedContractMethod<
    [],
    [[bigint, bigint] & { reserveX: bigint; reserveY: bigint }],
    "view"
  >;

  getStaticFeeParameters: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {
        baseFactor: bigint;
        filterPeriod: bigint;
        decayPeriod: bigint;
        reductionFactor: bigint;
        variableFeeControl: bigint;
        protocolShare: bigint;
        maxVolatilityAccumulator: bigint;
      }
    ],
    "view"
  >;

  getSwapIn: TypedContractMethod<
    [amountOut: BigNumberish, swapForY: boolean],
    [
      [bigint, bigint, bigint] & {
        amountIn: bigint;
        amountOutLeft: bigint;
        fee: bigint;
      }
    ],
    "view"
  >;

  getSwapOut: TypedContractMethod<
    [amountIn: BigNumberish, swapForY: boolean],
    [
      [bigint, bigint, bigint] & {
        amountInLeft: bigint;
        amountOut: bigint;
        fee: bigint;
      }
    ],
    "view"
  >;

  getTokenX: TypedContractMethod<[], [string], "view">;

  getTokenY: TypedContractMethod<[], [string], "view">;

  getVariableFeeParameters: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint] & {
        volatilityAccumulator: bigint;
        volatilityReference: bigint;
        idReference: bigint;
        timeOfLastUpdate: bigint;
      }
    ],
    "view"
  >;

  increaseOracleLength: TypedContractMethod<
    [newLength: BigNumberish],
    [void],
    "nonpayable"
  >;

  initialize: TypedContractMethod<
    [
      baseFactor: BigNumberish,
      filterPeriod: BigNumberish,
      decayPeriod: BigNumberish,
      reductionFactor: BigNumberish,
      variableFeeControl: BigNumberish,
      protocolShare: BigNumberish,
      maxVolatilityAccumulator: BigNumberish,
      activeId: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  isApprovedForAll: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [boolean],
    "view"
  >;

  mint: TypedContractMethod<
    [to: AddressLike, liquidityConfigs: BytesLike[], refundTo: AddressLike],
    [
      [string, string, bigint[]] & {
        amountsReceived: string;
        amountsLeft: string;
        liquidityMinted: bigint[];
      }
    ],
    "nonpayable"
  >;

  name: TypedContractMethod<[], [string], "view">;

  setStaticFeeParameters: TypedContractMethod<
    [
      baseFactor: BigNumberish,
      filterPeriod: BigNumberish,
      decayPeriod: BigNumberish,
      reductionFactor: BigNumberish,
      variableFeeControl: BigNumberish,
      protocolShare: BigNumberish,
      maxVolatilityAccumulator: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  swap: TypedContractMethod<
    [swapForY: boolean, to: AddressLike],
    [string],
    "nonpayable"
  >;

  symbol: TypedContractMethod<[], [string], "view">;

  totalSupply: TypedContractMethod<[id: BigNumberish], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "approveForAll"
  ): TypedContractMethod<
    [spender: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<
    [account: AddressLike, id: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "balanceOfBatch"
  ): TypedContractMethod<
    [accounts: AddressLike[], ids: BigNumberish[]],
    [bigint[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "batchTransferFrom"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      ids: BigNumberish[],
      amounts: BigNumberish[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "burn"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      ids: BigNumberish[],
      amountsToBurn: BigNumberish[]
    ],
    [string[]],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "collectProtocolFees"
  ): TypedContractMethod<[], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "flashLoan"
  ): TypedContractMethod<
    [receiver: AddressLike, amounts: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "forceDecay"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getActiveId"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getBin"
  ): TypedContractMethod<
    [id: BigNumberish],
    [[bigint, bigint] & { binReserveX: bigint; binReserveY: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "getBinStep"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getFactory"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getIdFromPrice"
  ): TypedContractMethod<[price: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getNextNonEmptyBin"
  ): TypedContractMethod<
    [swapForY: boolean, id: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOracleParameters"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint] & {
        sampleLifetime: bigint;
        size: bigint;
        activeSize: bigint;
        lastUpdated: bigint;
        firstTimestamp: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOracleSampleAt"
  ): TypedContractMethod<
    [lookupTimestamp: BigNumberish],
    [
      [bigint, bigint, bigint] & {
        cumulativeId: bigint;
        cumulativeVolatility: bigint;
        cumulativeBinCrossed: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPriceFromId"
  ): TypedContractMethod<[id: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getProtocolFees"
  ): TypedContractMethod<
    [],
    [[bigint, bigint] & { protocolFeeX: bigint; protocolFeeY: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "getReserves"
  ): TypedContractMethod<
    [],
    [[bigint, bigint] & { reserveX: bigint; reserveY: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "getStaticFeeParameters"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {
        baseFactor: bigint;
        filterPeriod: bigint;
        decayPeriod: bigint;
        reductionFactor: bigint;
        variableFeeControl: bigint;
        protocolShare: bigint;
        maxVolatilityAccumulator: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getSwapIn"
  ): TypedContractMethod<
    [amountOut: BigNumberish, swapForY: boolean],
    [
      [bigint, bigint, bigint] & {
        amountIn: bigint;
        amountOutLeft: bigint;
        fee: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getSwapOut"
  ): TypedContractMethod<
    [amountIn: BigNumberish, swapForY: boolean],
    [
      [bigint, bigint, bigint] & {
        amountInLeft: bigint;
        amountOut: bigint;
        fee: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getTokenX"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getTokenY"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getVariableFeeParameters"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint] & {
        volatilityAccumulator: bigint;
        volatilityReference: bigint;
        idReference: bigint;
        timeOfLastUpdate: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "increaseOracleLength"
  ): TypedContractMethod<[newLength: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "initialize"
  ): TypedContractMethod<
    [
      baseFactor: BigNumberish,
      filterPeriod: BigNumberish,
      decayPeriod: BigNumberish,
      reductionFactor: BigNumberish,
      variableFeeControl: BigNumberish,
      protocolShare: BigNumberish,
      maxVolatilityAccumulator: BigNumberish,
      activeId: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isApprovedForAll"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "mint"
  ): TypedContractMethod<
    [to: AddressLike, liquidityConfigs: BytesLike[], refundTo: AddressLike],
    [
      [string, string, bigint[]] & {
        amountsReceived: string;
        amountsLeft: string;
        liquidityMinted: bigint[];
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "setStaticFeeParameters"
  ): TypedContractMethod<
    [
      baseFactor: BigNumberish,
      filterPeriod: BigNumberish,
      decayPeriod: BigNumberish,
      reductionFactor: BigNumberish,
      variableFeeControl: BigNumberish,
      protocolShare: BigNumberish,
      maxVolatilityAccumulator: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "swap"
  ): TypedContractMethod<
    [swapForY: boolean, to: AddressLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[id: BigNumberish], [bigint], "view">;

  getEvent(
    key: "ApprovalForAll"
  ): TypedContractEvent<
    ApprovalForAllEvent.InputTuple,
    ApprovalForAllEvent.OutputTuple,
    ApprovalForAllEvent.OutputObject
  >;
  getEvent(
    key: "CollectedProtocolFees"
  ): TypedContractEvent<
    CollectedProtocolFeesEvent.InputTuple,
    CollectedProtocolFeesEvent.OutputTuple,
    CollectedProtocolFeesEvent.OutputObject
  >;
  getEvent(
    key: "CompositionFees"
  ): TypedContractEvent<
    CompositionFeesEvent.InputTuple,
    CompositionFeesEvent.OutputTuple,
    CompositionFeesEvent.OutputObject
  >;
  getEvent(
    key: "DepositedToBins"
  ): TypedContractEvent<
    DepositedToBinsEvent.InputTuple,
    DepositedToBinsEvent.OutputTuple,
    DepositedToBinsEvent.OutputObject
  >;
  getEvent(
    key: "FlashLoan"
  ): TypedContractEvent<
    FlashLoanEvent.InputTuple,
    FlashLoanEvent.OutputTuple,
    FlashLoanEvent.OutputObject
  >;
  getEvent(
    key: "ForcedDecay"
  ): TypedContractEvent<
    ForcedDecayEvent.InputTuple,
    ForcedDecayEvent.OutputTuple,
    ForcedDecayEvent.OutputObject
  >;
  getEvent(
    key: "OracleLengthIncreased"
  ): TypedContractEvent<
    OracleLengthIncreasedEvent.InputTuple,
    OracleLengthIncreasedEvent.OutputTuple,
    OracleLengthIncreasedEvent.OutputObject
  >;
  getEvent(
    key: "StaticFeeParametersSet"
  ): TypedContractEvent<
    StaticFeeParametersSetEvent.InputTuple,
    StaticFeeParametersSetEvent.OutputTuple,
    StaticFeeParametersSetEvent.OutputObject
  >;
  getEvent(
    key: "Swap"
  ): TypedContractEvent<
    SwapEvent.InputTuple,
    SwapEvent.OutputTuple,
    SwapEvent.OutputObject
  >;
  getEvent(
    key: "TransferBatch"
  ): TypedContractEvent<
    TransferBatchEvent.InputTuple,
    TransferBatchEvent.OutputTuple,
    TransferBatchEvent.OutputObject
  >;
  getEvent(
    key: "WithdrawnFromBins"
  ): TypedContractEvent<
    WithdrawnFromBinsEvent.InputTuple,
    WithdrawnFromBinsEvent.OutputTuple,
    WithdrawnFromBinsEvent.OutputObject
  >;

  filters: {
    "ApprovalForAll(address,address,bool)": TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;
    ApprovalForAll: TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;

    "CollectedProtocolFees(address,bytes32)": TypedContractEvent<
      CollectedProtocolFeesEvent.InputTuple,
      CollectedProtocolFeesEvent.OutputTuple,
      CollectedProtocolFeesEvent.OutputObject
    >;
    CollectedProtocolFees: TypedContractEvent<
      CollectedProtocolFeesEvent.InputTuple,
      CollectedProtocolFeesEvent.OutputTuple,
      CollectedProtocolFeesEvent.OutputObject
    >;

    "CompositionFees(address,uint24,bytes32,bytes32)": TypedContractEvent<
      CompositionFeesEvent.InputTuple,
      CompositionFeesEvent.OutputTuple,
      CompositionFeesEvent.OutputObject
    >;
    CompositionFees: TypedContractEvent<
      CompositionFeesEvent.InputTuple,
      CompositionFeesEvent.OutputTuple,
      CompositionFeesEvent.OutputObject
    >;

    "DepositedToBins(address,address,uint256[],bytes32[])": TypedContractEvent<
      DepositedToBinsEvent.InputTuple,
      DepositedToBinsEvent.OutputTuple,
      DepositedToBinsEvent.OutputObject
    >;
    DepositedToBins: TypedContractEvent<
      DepositedToBinsEvent.InputTuple,
      DepositedToBinsEvent.OutputTuple,
      DepositedToBinsEvent.OutputObject
    >;

    "FlashLoan(address,address,uint24,bytes32,bytes32,bytes32)": TypedContractEvent<
      FlashLoanEvent.InputTuple,
      FlashLoanEvent.OutputTuple,
      FlashLoanEvent.OutputObject
    >;
    FlashLoan: TypedContractEvent<
      FlashLoanEvent.InputTuple,
      FlashLoanEvent.OutputTuple,
      FlashLoanEvent.OutputObject
    >;

    "ForcedDecay(address,uint24,uint24)": TypedContractEvent<
      ForcedDecayEvent.InputTuple,
      ForcedDecayEvent.OutputTuple,
      ForcedDecayEvent.OutputObject
    >;
    ForcedDecay: TypedContractEvent<
      ForcedDecayEvent.InputTuple,
      ForcedDecayEvent.OutputTuple,
      ForcedDecayEvent.OutputObject
    >;

    "OracleLengthIncreased(address,uint16)": TypedContractEvent<
      OracleLengthIncreasedEvent.InputTuple,
      OracleLengthIncreasedEvent.OutputTuple,
      OracleLengthIncreasedEvent.OutputObject
    >;
    OracleLengthIncreased: TypedContractEvent<
      OracleLengthIncreasedEvent.InputTuple,
      OracleLengthIncreasedEvent.OutputTuple,
      OracleLengthIncreasedEvent.OutputObject
    >;

    "StaticFeeParametersSet(address,uint16,uint16,uint16,uint16,uint24,uint16,uint24)": TypedContractEvent<
      StaticFeeParametersSetEvent.InputTuple,
      StaticFeeParametersSetEvent.OutputTuple,
      StaticFeeParametersSetEvent.OutputObject
    >;
    StaticFeeParametersSet: TypedContractEvent<
      StaticFeeParametersSetEvent.InputTuple,
      StaticFeeParametersSetEvent.OutputTuple,
      StaticFeeParametersSetEvent.OutputObject
    >;

    "Swap(address,address,uint24,bytes32,bytes32,uint24,bytes32,bytes32)": TypedContractEvent<
      SwapEvent.InputTuple,
      SwapEvent.OutputTuple,
      SwapEvent.OutputObject
    >;
    Swap: TypedContractEvent<
      SwapEvent.InputTuple,
      SwapEvent.OutputTuple,
      SwapEvent.OutputObject
    >;

    "TransferBatch(address,address,address,uint256[],uint256[])": TypedContractEvent<
      TransferBatchEvent.InputTuple,
      TransferBatchEvent.OutputTuple,
      TransferBatchEvent.OutputObject
    >;
    TransferBatch: TypedContractEvent<
      TransferBatchEvent.InputTuple,
      TransferBatchEvent.OutputTuple,
      TransferBatchEvent.OutputObject
    >;

    "WithdrawnFromBins(address,address,uint256[],bytes32[])": TypedContractEvent<
      WithdrawnFromBinsEvent.InputTuple,
      WithdrawnFromBinsEvent.OutputTuple,
      WithdrawnFromBinsEvent.OutputObject
    >;
    WithdrawnFromBins: TypedContractEvent<
      WithdrawnFromBinsEvent.InputTuple,
      WithdrawnFromBinsEvent.OutputTuple,
      WithdrawnFromBinsEvent.OutputObject
    >;
  };
}
